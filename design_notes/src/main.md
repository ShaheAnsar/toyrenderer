# Main Design Doc
## Name of the Engine : Red Blue Echo
### TOC
* Misc
* Shader System
* Material System
* Command System
* CommandQueue System
* RenderPass System
* Reflection Probe System
* Mesh System
* Scene System

## Misc
In json, certain internal syntax is active.
When it comes to names (ShaderName, ShaderProgramName etc),
they are considered GUIDs, and they also have namespaces, separated by a ':'.
Things in these files are referenced by their names. No two names can be
same regardless of type (MaterialName or ShaderName, for ex).
When it comes to path, '<BASE>' relates to the base path of the project.

## Shader System
The Shader itself is always going to be 
glsl compiled to SPIR-V. The shader name&GUID, what type of
shader it is -

* Vert, Frag, Geom, Tess and Comp shaders

it's path is all recorded in json. The shader json
description will also have information on the inputs, outputs and uniforms/ssbos
in the shader. Ideally, it'll be generated by a golang program that processes
shaders directly. For now, by hand is fine. Certain input, output, UBO/SSBO
names are internally defined (Color output, Vertex Input, Lighting info etc)
A shader program can reference any of these shaders to create a program.  
  
All GLSL shaders can also access **shader libraries**.
These are simple pieces of code that can be included using
a preprocessor - 

```
...
#=
import 'shaders.water' // Import the water library from the shader namespace
// The name is used to get the shader
// from the json files.
// From here on out, calling  @shader.water.main(), will call the main()
// function in shaders.water
import 'shaders.random'
=#
...
```

It can be used for normal library stuff as well as combining shaders.
If there's a water module and a ground module, this system can
be used to blend between them using a texture, for example.
Shader Libraries also produce shader library json output.

### Details of the glsl preprocessor
It's mainly used for shader libraries.
Shader libraries are special shaders designed to be included
in other shaders. There are many types-  

* Generic Shader Library (Can be imported by any shader type)
* Vertex Shader Library (Can be imported only by a vertex shader)
* Fragment Shader Library (Can be imported only by a fragment shader)
* Geom Shader Library (Can be imported only by a geometry shader)
* Tessellation Shader Library (Can be imported only by a tessellation shader)  

Shader libraries expose required inputs and uniforms. These linkables
can be linked together either via name, or via location/binding number when
imported. This is passed as a flag to the preprocessor. It can also
be included in the file itself - 
```
#= // Delimiters for a block of preprocessor code
!link_method name // Can also be number
import 'shaders.water'
=#
```
The objects themselves can also be linked to an input manually, or spun off
to a new one.
```
layout(location = 10) in vec3 posName123;
#=
import 'shaders.water'
!link shaders.water.pos posName123
!make shaders.water.tex_image 5, rgba16f// tex_image is an image2D in
// shaders.water. The stuff that comes next is the argument to spin it off
// into another uniform, in this case, the binding slot and the format.
=#
```
It's important for the name to be declared before it's linked to.  

A shader library is a heavily preprocessed glsl file. In these
files, there's no need to use the preprocessor delimiters, they're enabled
by default. The have the extension - '.rbesl'. Many exclusive commands
become available for these files.
```
#version 460 core
@decl in vec3 pos;
@decl in vec2 uv;
@decl layout(std140) uniform buffer_t{ // std140 is set only here.
// Anything to do with memory layout will always be declared here.
// Undeclared memory layout causes errors.
	mat4 mvpM;
	mat4 mviewM;
}buffer1;

vec4 calc_noise() { // This is an example of an internal function
	...
}

@pub vec4 perlin(...) { // This is an example of an exposed function
// Only exposed functions can be called from the outside
	...
}
```
When a shader library is imported by another shader library,
the required inputs/uniforms of the imported library can be linked
to one of the exposed inputs/uniforms, or be passed to be linked
explicitly. When passed(default), it's equivalent to being linked
to an input of the same name, ie, the input/output becomes part of
the current namespace.
```
import 'shaders.noise' // Defines seed_tex, and uv

@decl in vec2 uv;
!link shaders.noise.uv uv
//shaders.noise.uv is now linked to the current uv. seed_tex is passed on by default.
```

## Material System
The material system consists of json files.  
A material is simply a bunch of shaders, and some
required files (like textures). This is all written in
json.
